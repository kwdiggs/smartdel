#!/bin/bash

# create recycle bin if not already created
recbin='smartdel_recycle'
if [ ! -d ~/$recbin ]
then
	dir=$PWD
	cd ~
	mkdir $recbin
	cd $dir
fi

# log the tuple in the recycle bin table
#log () {
#	tuple="$1 $PWD"
#	if grep -Fxq "$tuple" ~/$recbin/.table.txt
#	then
#   		echo "okay!"
#	else
#    		echo "too late!"
#		echo "$tuple" >> ~/$recbin/.table.txt
#	fi
#}

# DRY functions to move files to and from our recycle bin
delete () {
	# variables for concatenation
	filename=$1					# filename to be manipulated if duplicate is detected
	one='_1'					# to be appended if file is duplicate for the first time
	filename_one=$filename$one			# concatenated first duplication
	under="_"					# underscore

	# if file is not of the correct format, append _1 to ensure uniqueness
	if [[ "$filename" =~ "$under" ]]  		# if filename contain underscore
	then
		echo "huzzah"
		num="${filename##*_}"
		expression='^[0-9]+$'
		if ! [[ $num =~ $expression ]]		# if integer follows underscore, formatting is correct
		then
			filename=$filename_one
		fi
	else
		filename=$filename_one
	fi
	# or increment suffix to append
	if [ -e ~/$recbin/$filename ]
	then
		while [ -e ~/$recbin/$filename ]
		do
			num="${filename##*_}" 		# get num
			num=`expr $num + 1`		# increment num
			num=$under$num			# prepend underscore
			filename="${filename%_*}"	# remove old suffix
			filename=$filename$num		# add new suffix
		done

		echo "smartdel: this file already exists, moved as '$filename'"
	fi

	# move file
        log $filename
	mv $1 ~/$recbin/$filename
}

restore () {
	# variables for concatenation
        filename=$1
	path="~/$recbin/$filename*
	ast='*'
	files=($path)
	echo "${files[0]}"
        # append char to ensure uniqueness
        if [ -e ./$filename ]
        then
                while [ -e ./$filename ]
                do
                        filename=$filename$var
                done

                echo "smartdel: this file already exists, but not to worry, moved with new name '$filename'"
                mv ~/$recbin/$1 ~/$recbin/$filename
        fi

        # move file
	mv ~/$rebin/$filename .
}

o_restore () {
	
}

# paramaterize the option, if it exists. Else, this loop will be skipped
while getopts ":d:r:o:" opt;
do
	# in the case of wildcards, shift all filenames down to $2
	while [ -n "$2" ]
	do
		case $opt in
               		d) delete $2 ;;
               		r) restore $2 ;;
			o) o_restore $2 ;;
               		\?) echo "invalid command: -$OPTARG" ;;
       		esac
		shift # shift down command vars by 1
	done
	exit # exit if getops found an option
done

# if there is no specified option, delete by default
while [ -n "$1" ]
do
	delete $1
	shift
done







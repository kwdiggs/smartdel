#!/bin/bash

# create recycle bin
recbin='smartdel_recycle'
table='.table.txt'
if [ ! -d ~/$recbin ]
then
	dir=$PWD
	cd ~
	mkdir $recbin
	cd $dir
fi

# create table
if [ ! -e ~/$recbin/$table ]
then
	dir=$PWD
	cd ~/$recbin
	echo > $table
	cd $dir
fi

# log the tuple in the recycle bin table
log () {
	tuple="$1 $PWD"
	if ! grep -Fxq "$tuple" ~/$recbin/$table
	then
		echo "$tuple" >> ~/$recbin/$table
	fi
}

# DRY functions to move files to and from our recycle bin
delete () {
	# variables for concatenation
	filename=$1					# filename to be manipulated if duplicate is detected
	one='_1'					# to be appended if file is duplicate for the first time
	filename_one=$filename$one			# concatenated first duplication
	under="_"					# underscore

	# append _1 to ensure uniqueness
	if [[ "$filename" =~ "$under" ]]  		# if filename contain underscore
	then
		num="${filename##*_}"			# get number after final underscore
		expression='^[0-9]+$'			# regex expression detecting integers
		if ! [[ $num =~ $expression ]]		# if integer follows underscore, formatting is correct
		then
			filename=$filename_one		# otherwise append _1
		fi
	elif [ -e ~/$recbin/$filename ]
	then
		filename=$filename_one			# append _1
	fi
	# or increment suffix to append
	if [ -e ~/$recbin/$filename ]			# account for files that may already have the same filename_number name
	then
		while [ -e ~/$recbin/$filename ]	# if this filename_number already exists, try filename_number+1
		do
			num="${filename##*_}" 		# get num
			num=`expr $num + 1`		# increment num
			num=$under$num			# prepend underscore
			filename="${filename%_*}"	# remove old suffix
			filename=$filename$num		# add new suffix
		done

		echo "smartdel: this file already exists in recycle bin, moved as '$filename'"
	fi

	# move file
	mv $1 ~/$recbin/$filename
	log $filename
}

restore () {
	# variables for concatenation
        filename=$1
	path="~/$recbin/$filename*"
	ast='*'
	files=($path)
	echo "${files[0]}"
        # append char to ensure uniqueness
        if [ -e ./$filename ]
        then
                while [ -e ./$filename ]
                do
                        filename=$filename$var
                done

                echo "smartdel: this file already exists, moved as '$filename'"
                mv ~/$recbin/$1 ~/$recbin/$filename
        fi

        # move file
	mv ~/$recbin/$filename .
}

o_restore () {
	# get the filename and path from our table and mv
	path=$(grep "$1" ~/$recbin/$table | head -1 | cut -f 2 -d ' ')
	mv ~/$recbin/$1 $path

	# delete the entry from the table
	string="$1 $path"
	echo "STRING: "
	echo  $string
	sed -i 's@$string@d@' ~/$recbin/$table
}

# paramaterize the option, if it exists. Else, this loop will be skipped
while getopts ":d:r:o:" opt;
do
	# in the case of wildcards, shift all filenames down to $2
	while [ -n "$2" ]
	do
		case $opt in
               		d) delete $2 ;;
               		r) restore $2 ;;
			o) o_restore $2 ;;
               		\?) echo "invalid command: -$OPTARG" 
			    exit # don't try to use invalid arguments
			    ;;
       		esac
		shift # shift down command vars by 1
	done
	exit # exit if getops found an option
done

# if there is no specified option, delete by default
while [ -n "$1" ]
do
	delete $1
	shift
done







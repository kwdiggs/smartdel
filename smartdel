#!/bin/bash
# Keenan Diggs 2014

recbin='smartdel_recycle'			# name of recycle bin
table='.table.txt'				# name of recycle bin table
integer='^[0-9]+$'                              # regex expression detects integers
question="?"					# question mark
under="_"                                       # underscore
slash="/"                                       # forward slash
one="_1"					# underscore 1
parenth=")"					# closing parentheses
ast="*"						# asterisk

# create recycle bin
if [ ! -d ~/$recbin ]
then
	dir=$PWD
	cd ~
	mkdir $recbin
	cd $dir
fi

# create table
if [ ! -f ~/$recbin/$table ]
then
	dir=$PWD
	cd ~/$recbin
	echo > $table
	cd $dir
fi

# log the tuple into the recycle bin table
log () {
	# human readable variable name
	tuple="$1 $2"

	# concatenate to table if tuple is not already in table
	if ! grep -Fxq "$tuple" ~/$recbin/$table
	then
		echo "$tuple" >> ~/$recbin/$table
	fi
}

# ensure filename uniquness of the form: name_vNum
ensure_unique () {
	# human readable
	filename=$1$one

       	# increment suffix if filename already in use
        if [ -f ~/$recbin/$filename ]
        then
		# remove suffix num, increment, re-concatenate
               	while [ -f ~/$recbin/$filename ]
               	do
                       	num="${filename##*_}"
                       	num=`expr $num + 1`
                       	num=$under$num
                       	filename="${filename%_*}"
                       	filename=$filename$num
               	done
        fi

	echo "$filename"
}

# move file to bin, log filename and path in table
delete () {
	# new filename to be used
	filename=$1

	# if user tries to delete nonexistant file, display error message and terminate
	if [[ ! -f $filename ]]
	then
		echo "smartdel: cannot delete '$filename': no such file exists"
		exit
	fi

	# if input is of the format: /home/path/filename; ~/path/filename; ../filename; ./filename; subdir/filename
	# ~	then store the path and retrieve the filename
	# all paths contain slashes
	if [[ "$filename" =~ "$slash" ]]
	then
		# get the path and name of the file
		file_path="${filename%/*}"
		filename="${filename##*/}"

		# if input begins with ~, or /, do not prepend PWD; otherwise prepend PWD
		if [[ $filename == /* ]] || [[ $filename == ~* ]]
        	then
			file_path=$file_path$slash
		else
			file_path=$PWD$slash$file_path$slash
              	fi
	fi

	# ensure filename is unique before moving to bin
	filename=$(ensure_unique $filename)

	# move and log in recycle bin table
	if [ -n "$file_path" ]
	then
		mv $file_path$1 ~/$recbin/$filename
                log $filename $file_path
	else
		mv $1 ~/$recbin/$filename
                log $filename $PWD$slash
	fi
}

# removes a 2-tuple from table when the corresponding file leaves the recycle bin
clean_table () {
	# get the path portion of the 2-tuple and append it to a search string after filename
	filename=$1
	path=$(grep "$1" ~/$recbin/$table | head -1 | cut -f 2 -d ' ')
        search_str="$filename $path"

	# replace 2-tuple with a blank line, then remove blank lines from the file
        sed -i "s@^$search_str@@" ~/$recbin/$table
        sed -i "/^$/d" ~/$recbin/$table

	# return pathname to caller
	echo $path
}

# helper method for wildcard support
not_empty () {
	[[ -f $1 ]]
}

# move files from recycle bin to current directory
restore () {
	# human readable filename, searchstring, and array to hold paths/filename
	echo "res: you gave me: " $1
        filename=$1
	str=$filename$under$ast
	declare -a array
	count="1"
	skip=$2 # used by o_restore

	# search for all versions of file, add to array
	if not_empty ~/$recbin/$str
	then
		for f in `find ~/$recbin/$str`
		do
			array[$count]=$f
			let "count=$count+1"
		done
	else
		# display error message if no files could be found from user-generated search string
                echo "smartdel: file '$filename' not found in recycle bin"
	fi

	# if more than one option exists, allow user to choose based on time last edited
	if [ $count -gt "2" ]
	then
		echo "smartdel: multiple files with  name '$filename' exist. Please choose one to restore based last edit time"
		option="1"
		for version in "${array[@]}"
		do
			# get name and time last edited, display as an option
			name="${version##*/}"
			time=$(stat -c%y $version)
			echo "$option$parenth name: $name  last edited: $time"

			# put filename without path into a filename array
			new_value="${array[$option]}"
			new_value="${new_value##*/}"

			# increment option
			let "option=$option+1"
		done

		# user input is file to restore
		read choice
		if [[ $choice =~ $integer ]] && [ "${array[$choice]}" ] # user chooses a valid array index
		then
			# clean bin table
			name="${array[$choice]}"
                	name="${name##*/}"
                        path=$(clean_table $name)
			name="${name%_*}"


			if [ ! "$skip" == "skip" ] # used by o_restore
			then
				# restore the file to the current directory, retain original name
                        	mv "${array[$choice]}" ./$name
			else
				mv "${array[$choice]}" $path/$name
			fi
		else
			echo "invalid input"
			exit
		fi
	# only 1 file
	elif [ $count -eq "2" ]
	then
		# clean bin table
		name="${array[1]}"
		name="${name##*/}"
		path=$(clean_table $name)
		name="${name%_*}"

		if [ ! "$skip" == "skip" ] # used by o_restore
		then
			# move file
                	mv "${array[1]}" ./$name
		else
			mv "${array[1]}" $path/$name
		fi
	fi
}

# move file from recycle bin to the directory they were removed from
o_restore () {
	filename=$1
	skip="skip"
	restore $filename $skip
}

# paramaterize the option, if it exists. else, skip this loop
while getopts ":d:r:o: " opt;
do
	echo "this is 1" $2
	while [ -n "$2" ]					# in the case of wildcards, shift all filenames down to $2
	do
		echo "this is 2" $2
		case $opt in
               		d) 	delete $2 ;;			# smartdel -d
               		r) 	#if [[ $2 == *"*"* ]] && [[ $2 == *"?"* ]]
				#then
				#echo "it contains!"
				#if not_empty ~/$recbin/$2
				#then
				#	echo "booyah!"
				#	declare -a array
				#	for result in `find ~/$recbin/$2`
				#	do
				#		# pass results in one by one, if the filename has already been used, skip
				# restore the file to the current directory, retain original name
                        	#		mv "${array[$choice]}" ./$filename
				#		result="${result##*/}"
				#		prefix="${result%*_}"
				#		if [ ! "${array[$prefix]}" ]
				#	        then
				#			array[$prefix]="in use"
				#			restore $result
				#		fi
                                #       	done
			   	#else
				#	echo "smartdel: cannot restore '$2'. No such file in recycle bin"
			   	#fi

				#else
					restore $2
				#fi
				;;
			o) o_restore $2 ;; 		# smartdel -o, supports identical names, does not support wildcards
               		\?) echo "invalid command: -$OPTARG"
			    exit  ;;				# don't proceed with invalid arguments
       		esac
		shift 						# shift down command variables by 1 index
	done
	exit 							# don't do default delete, end here
done

# smartdel with no options, same as smartdel -d
while [ -n "$1" ]
do
	delete $1
	shift
done

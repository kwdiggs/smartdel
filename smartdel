#!/bin/bash

recbin='smartdel_recycle'			# name of recycle bin
table='.table.txt'				# name of recycle bin table
under="_"                                       # underscore
slash="/"                                       # forward slash
one="_1"					# underscore 1

# create recycle bin
if [ ! -d ~/$recbin ]
then
	dir=$PWD
	cd ~
	mkdir $recbin
	cd $dir
fi

# create table
if [ ! -e ~/$recbin/$table ]
then
	dir=$PWD
	cd ~/$recbin
	echo > $table
	cd $dir
fi

# log the tuple into the recycle bin table
log () {
	tuple="$1 $2"					# human readable variable

	# concatenate to table if tuple is not already in table
	if ! grep -Fxq "$tuple" ~/$recbin/$table
	then
		echo "$tuple" >> ~/$recbin/$table
	fi
}

# ensure filename uniquness of the form name_versionNumber
ensure_unique () {
	filename=$1					# human readable

        if [[ "$filename" =~ "$under" ]]                # if filename contain underscore
        then
                num="${filename##*_}"                   # get number after final underscore
                expression='^[0-9]+$'                   # regex expression detecting integers
                if ! [[ $num =~ $expression ]]          # if integer follows underscore, formatting is correct
                then
                        filename=$filename$one          # otherwise append _1
                fi
        elif [ -e ~/$recbin/$filename ]			# append _1 if no underscore in filename at all
        then
                filename=$filename$one                  # append _1
        fi

        # or increment suffix to append
        if [ -e ~/$recbin/$filename ]                   # account for files in the bin of the format: duplicateName__number
        then
                while [ -e ~/$recbin/$filename ]        # if this filename_number already exists, try filename_number+1
                do
                        num="${filename##*_}"           # get num
                        num=`expr $num + 1`             # increment num
                        num=$under$num                  # prepend underscore
                        filename="${filename%_*}"       # remove old suffix
                        filename=$filename$num          # add new suffix
                done
        fi

	echo "$filename"
}

# move files to recycle bin
delete () {
	filename=$1					# new filename to be used

	# if input is of the format: /path/to/filename; ~/dir/sub/filename; ../filename; ./filename; subdir/filename
	# store the path and retrieve the filename
	if [[ "$filename" =~ "$slash" ]]		# all paths contain slashes
	then

		file_path="${filename%/*}"      	# get the path to the file
		filename="${filename##*/}"      	# get the filename

		# if input begins with ~, or /, do not prepend pwd
		if [[ $filename == /* ]] || [[ $filename == ~* ]]
        	then
			file_path=$file_path$slash		# do nothing, e.g. ~/dir/subdir/filename
		else
			file_path=$PWD$slash$file_path$slash	# otherwise prepend pwd, e.g. pwd/subdirectory/filename; pwd/../filename; pwd/./filename
              	fi

	fi

	filename=$(ensure_unique $filename)		# ensure filename is being stored uniquely in bin
        echo "filepath: " $file_path
        echo "filename: " $filename


	# move and log in recycle bin table
	if [ -n "$file_path" ]
	then
		mv $file_path$1 ~/$recbin/$filename	# move the file at specified path to recbin with new name
                log $filename $file_path		# log this tuple
	else
		mv $1 ~/$recbin/$filename		# move to recbin with new name
                log $filename $PWD$slash		# log this tuple
	fi
}

# remove tuples from table when the corresponding file leaves the recycle bin
clean_table () {
	filename=$1								# human readable
	path=$(grep "$1" ~/$recbin/$table | head -1 | cut -f 2 -d ' ')          # get the path portion of the tuple
        search_str="$1 $path"                                                   # search string is the tuple store in the table, filename-space-path

        sed -i "s@^$search_str@@" ~/$recbin/$table              		# replace the tuple with a blank line
        sed -i "/^$/d" ~/$recbin/$table                         		# remove blank lines from table
	echo "$path"
}

# move files from recycle bin to current directory
restore () {
        filename=$1						# human readable
	path=$(clean_table $filename)				# clean bin table
	mv ~/$recbin/$1 .					# move file
}

# move file from recycle bin to the directory they were removed from
o_restore () {
	filename=$1						# human readable

	path=$(clean_table $filename)				# get destination and clean table
	mv ~/$recbin/$filename $path				# move the file to the destination
}

# paramaterize the option, if it exists. else, skip this loop
while getopts ":d:r:o: " opt;
do
	while [ -n "$2" ]					# in the case of wildcards, shift all filenames down to $2
	do
		case $opt in
               		d) delete $2 ;;				# smartdel -d
               		r) restore "$2" ;;			# smartdel -r
			o) o_restore $2 ;;			# smartdel -o
               		\?) echo "invalid command: -$OPTARG"	# display error message if argument is invalid
			    exit  ;;				# don't proceed with invalid arguments
       		esac
		shift 						# shift down command variables by 1 index
	done
	exit 							# don't do default delete, end here
done

# delete by default, same as smartdel -d
while [ -n "$1" ]
do
	delete $1
	shift
done

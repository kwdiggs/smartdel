#!/bin/bash
# Keenan Diggs 2014

recbin='smartdel_recycle'			# name of recycle bin
table='.table.txt'				# name of recycle bin table
under="_"                                       # underscore
slash="/"                                       # forward slash
one="_1"					# underscore 1
parenth=")"					# closing parentheses
ast="*"						# asterisk
integer='^[0-9]+$' 	                  	# regex expression detecting integers


# create recycle bin
if [ ! -d ~/$recbin ]
then
	dir=$PWD
	cd ~
	mkdir $recbin
	cd $dir
fi

# create table
if [ ! -e ~/$recbin/$table ]
then
	dir=$PWD
	cd ~/$recbin
	echo > $table
	cd $dir
fi

# log the tuple into the recycle bin table
log () {
	tuple="$1 $2"					# human readable variable

	# concatenate to table if tuple is not already in table
	if ! grep -Fxq "$tuple" ~/$recbin/$table
	then
		echo "$tuple" >> ~/$recbin/$table
	fi
}

# ensure filename uniquness of the form: name_vNum
ensure_unique () {
	filename=$1					# human readable

        if [[ "$filename" =~ "$under" ]]                # if filename contain underscore
        then
                num="${filename##*_}"                   # get number after final underscore
                if ! [[ $num =~ $integer ]]	        # if integer follows underscore, formatting is correct
                then
                        filename=$filename$one          # otherwise append _1
                fi
        elif [ -e ~/$recbin/$filename ]			# append _1 if no underscore in filename at all
        then
                filename=$filename$one                  # append _1
        fi

        # or increment suffix to append
        if [ -e ~/$recbin/$filename ]                   # account for files in the bin of the format: duplicateName_number
        then
                while [ -e ~/$recbin/$filename ]        # if this filename_number already exists, try filename_number+1
                do
                        num="${filename##*_}"           # get num
                        num=`expr $num + 1`             # increment num
                        num=$under$num                  # prepend underscore
                        filename="${filename%_*}"       # remove old suffix
                        filename=$filename$num          # add new suffix
                done
        fi

	echo "$filename"
}

# move files to recycle bin, log in bin table the filename and the exact directory they were found in
delete () {
	filename=$1					# new filename to be used

	# if input is of the format: /path/to/filename; ~/dir/sub/filename; ../filename; ./filename; subdir/filename
	# store the path and retrieve the filename
	if [[ "$filename" =~ "$slash" ]]		# all paths contain slashes
	then

		file_path="${filename%/*}"      	# get the path to the file
		filename="${filename##*/}"      	# get the filename

		# if input begins with ~, or /, do not prepend pwd
		if [[ $filename == /* ]] || [[ $filename == ~* ]]
        	then
			file_path=$file_path$slash		# do nothing, e.g. ~/dir/subdir/filename
		else
			file_path=$PWD$slash$file_path$slash	# otherwise prepend pwd, e.g. pwd/subdirectory/filename; pwd/../filename; pwd/./filename
              	fi

	fi

	filename=$(ensure_unique $filename)		# ensure filename is being stored uniquely in bin

	# move and log in recycle bin table
	if [ -n "$file_path" ]
	then
		mv $file_path$1 ~/$recbin/$filename	# move the file at specified path to recbin with new name
                log $filename $file_path		# log this tuple
	else
		mv $1 ~/$recbin/$filename		# move to recbin with new name
                log $filename $PWD$slash		# log this tuple
	fi
}

# remove tuples from table when the corresponding file leaves the recycle bin
clean_table () {
	filename=$1								# human readable
	path=$(grep "$1" ~/$recbin/$table | head -1 | cut -f 2 -d ' ')          # get the path portion of the tuple
        search_str="$1 $path"                                                   # search string is the tuple store in the table, filename-space-path

        sed -i "s@^$search_str@@" ~/$recbin/$table              		# replace the tuple with a blank line
        sed -i "/^$/d" ~/$recbin/$table                         		# remove blank lines from table
	echo $path								# return the path to caller
}

# helper method for wildcard support
not_empty () {
	[[ -e $1 ]]
}

# move files from recycle bin to current directory
restore () {
        filename=$1						# human readable
	str=$filename$under$ast					# append _* for search string
	declare -a array					# array to hold possible duplicates
	count=0                                                 # count variable

	# if original version exists, add it to the array
	if [ -e ~/$recbin/$filename ]
	then
		array[$count]=~/$recbin/$filename		# store original in array
		let "count=$count+1"				# increment counter
	fi

	# search for all subsquent versions, add to array
	if not_empty ~/$recbin/$str
	then
		for f in `find ~/$recbin/$str`
		do
			array[$count]=$f				# store all versions into array
			let "count=$count+1"				# increment counter
		done
	fi

	# if more than one option exists, allow user to choose based on time last edited
	if [ $count -gt "1" ]
	then
		echo "smartdel: more than one file with name $filename exists, please choose one based on time last edited"
		count=0						# reset count
		for version in "${array[@]}"			# iterate through all versions
		do
			time=$(stat -c%y $version)		# get time last edited
			echo "$count$parenth $time"		# diplay as an option
			let "count=$count+1"			# increment count
		done

		# user selects file to restore
		read choice
		if [[ $choice =~ $integer ]] && [ "${array[$choice]}" ] # user chooses a valid array index
		then
			mv "${array[$choice]}" .			# move file
			path=$(clean_table $filename)			# clean bin table
		else
			echo "invalid input"				# display error message
			exit						# terminate
		fi
	elif [ $count -eq "1" ]
	then
		mv "${array[0]}" . 	                        # move file
                path=$(clean_table $filename)                   # clean bin table
	else
		echo "smartdel: file '$filename' not found in recycle bin"
	fi
}

# move file from recycle bin to the directory they were removed from
o_restore () {
	filename=$1						# human readable

	path=$(clean_table $filename)				# get destination and clean table
	mv ~/$recbin/$filename $path				# move the file to the destination
}

# paramaterize the option, if it exists. else, skip this loop
while getopts ":d:r:o: " opt;
do
	while [ -n "$2" ]					# in the case of wildcards, shift all filenames down to $2
	do
		case $opt in
               		d) delete $2 ;;				# smartdel -d
               		r) restore $2 ;;			# smartdel -r
			o) o_restore $2 ;;			# smartdel -o
               		\?) echo "invalid command: -$OPTARG"	# display error message if argument is invalid
			    exit  ;;				# don't proceed with invalid arguments
       		esac
		shift 						# shift down command variables by 1 index
	done
	exit 							# don't do default delete, end here
done

# delete by default, same as smartdel -d
while [ -n "$1" ]
do
	delete $1
	shift
done
